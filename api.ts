/* tslint:disable */
/* eslint-disable */
/**
 * NGDL API
 *  This is the API document for the NGDL project. It is a work in progress and is subject to change. This documentation is provided for the purpose of testing and auditing the integrity of the platform. It is not intended for production use.<br/><br/> The API is currently in version <b>1.0.0</b>.<br/> Developed by: <b>The Boolean Technology Ltd.</b><br/> Developed for: <b>Nehemiah Grace Developer Limited</b><br/> 
 *
 * The version of the OpenAPI document: v1
 * Contact: tobisholanke@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddBankToTransaction
 */
export interface AddBankToTransaction {
    /**
     * Transaction ID
     * @type {number}
     * @memberof AddBankToTransaction
     */
    'transaction': number;
    /**
     * Bank code
     * @type {string}
     * @memberof AddBankToTransaction
     */
    'bank': AddBankToTransactionBankEnum;
    /**
     * Account name
     * @type {string}
     * @memberof AddBankToTransaction
     */
    'account_name': string;
    /**
     * Account number
     * @type {string}
     * @memberof AddBankToTransaction
     */
    'account_number': string;
}

export const AddBankToTransactionBankEnum = {
    _044: '044',
    _023: '023',
    _063: '063',
    _050: '050',
    _070: '070',
    _011: '011',
    _214: '214',
    _058: '058',
    _030: '030',
    _301: '301',
    _082: '082',
    _014: '014',
    _076: '076',
    _039: '039',
    _232: '232',
    _032: '032',
    _033: '033',
    _215: '215',
    _035: '035',
    _057: '057'
} as const;

export type AddBankToTransactionBankEnum = typeof AddBankToTransactionBankEnum[keyof typeof AddBankToTransactionBankEnum];

/**
 * 
 * @export
 * @interface Allowance
 */
export interface Allowance {
    /**
     * 
     * @type {number}
     * @memberof Allowance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Allowance
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Allowance
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Allowance
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Allowance
     */
    'salary_percent'?: number;
    /**
     * 
     * @type {string}
     * @memberof Allowance
     */
    'pay_frequency'?: AllowancePayFrequencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Allowance
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Allowance
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Allowance
     */
    'employee'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Allowance
     */
    'group'?: number | null;
}

export const AllowancePayFrequencyEnum = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    BiAnnually: 'bi-annually',
    Annually: 'annually'
} as const;

export type AllowancePayFrequencyEnum = typeof AllowancePayFrequencyEnum[keyof typeof AllowancePayFrequencyEnum];

/**
 * 
 * @export
 * @interface AllowancesList200Response
 */
export interface AllowancesList200Response {
    /**
     * 
     * @type {number}
     * @memberof AllowancesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof AllowancesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AllowancesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Allowance>}
     * @memberof AllowancesList200Response
     */
    'results': Array<Allowance>;
}
/**
 * 
 * @export
 * @interface ApprovalForm
 */
export interface ApprovalForm {
    /**
     * Category ID
     * @type {number}
     * @memberof ApprovalForm
     */
    'category': number;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'id'?: number;
    /**
     * 
     * @type {Folder}
     * @memberof Asset
     */
    'folder': Folder;
    /**
     * 
     * @type {Category}
     * @memberof Asset
     */
    'category': Category;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'asset_value': number;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'asset_age': number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'media_gallery'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'purchase_form': string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'purchase_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'purchase_price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'purchase_from': string;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    'has_warranty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'warranty_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'warranty_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'warranty_to'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'warranty_cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'warranty_note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'warranty_status'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    'is_physical'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    'is_movable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'annual_depreciation'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    'is_depreciable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'status'?: AssetStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'condition'?: AssetConditionEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'frequency_of_maintenance'?: AssetFrequencyOfMaintenanceEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'image'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'created_by'?: number | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof Asset
     */
    'transactions': Set<number>;
}

export const AssetStatusEnum = {
    InProcurement: 'in_procurement',
    InRepair: 'in_repair',
    InDisposal: 'in_disposal',
    InUse: 'in_use',
    InStorage: 'in_storage',
    InLost: 'in_lost',
    InStolen: 'in_stolen',
    InLeasing: 'in_leasing',
    InRent: 'in_rent',
    InBorrow: 'in_borrow',
    InDonation: 'in_donation',
    Others: 'others'
} as const;

export type AssetStatusEnum = typeof AssetStatusEnum[keyof typeof AssetStatusEnum];
export const AssetConditionEnum = {
    Good: 'good',
    Bad: 'bad',
    Maintenance: 'maintenance'
} as const;

export type AssetConditionEnum = typeof AssetConditionEnum[keyof typeof AssetConditionEnum];
export const AssetFrequencyOfMaintenanceEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    BiAnnually: 'bi_annually',
    Yearly: 'yearly'
} as const;

export type AssetFrequencyOfMaintenanceEnum = typeof AssetFrequencyOfMaintenanceEnum[keyof typeof AssetFrequencyOfMaintenanceEnum];

/**
 * 
 * @export
 * @interface AssetsList200Response
 */
export interface AssetsList200Response {
    /**
     * 
     * @type {number}
     * @memberof AssetsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof AssetsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof AssetsList200Response
     */
    'results': Array<Asset>;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'approved_spendings'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'total_spent'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'percent_spent'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'amount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Budget
     */
    'strict_spending'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'category'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'created_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'updated_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'budget_cycle'?: number | null;
}
/**
 * 
 * @export
 * @interface BudgetCycle
 */
export interface BudgetCycle {
    /**
     * 
     * @type {number}
     * @memberof BudgetCycle
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetCycle
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BudgetCycle
     */
    'created_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BudgetCycle
     */
    'updated_by'?: number | null;
}
/**
 * 
 * @export
 * @interface BudgetCyclesList200Response
 */
export interface BudgetCyclesList200Response {
    /**
     * 
     * @type {number}
     * @memberof BudgetCyclesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof BudgetCyclesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BudgetCyclesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BudgetCycle>}
     * @memberof BudgetCyclesList200Response
     */
    'results': Array<BudgetCycle>;
}
/**
 * 
 * @export
 * @interface BudgetsList200Response
 */
export interface BudgetsList200Response {
    /**
     * 
     * @type {number}
     * @memberof BudgetsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof BudgetsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BudgetsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Budget>}
     * @memberof BudgetsList200Response
     */
    'results': Array<Budget>;
}
/**
 * 
 * @export
 * @interface CategoriesList200Response
 */
export interface CategoriesList200Response {
    /**
     * 
     * @type {number}
     * @memberof CategoriesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof CategoriesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoriesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoriesList200Response
     */
    'results': Array<Category>;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'module'?: CategoryModuleEnum;
}

export const CategoryModuleEnum = {
    All: 'all',
    Asset: 'asset',
    Account: 'account',
    Project: 'project',
    Document: 'document',
    Inventory: 'inventory',
    Budget: 'budget',
    Bid: 'bid',
    Contract: 'contract',
    Facility: 'facility',
    HumanResource: 'human_resource'
} as const;

export type CategoryModuleEnum = typeof CategoryModuleEnum[keyof typeof CategoryModuleEnum];

/**
 * 
 * @export
 * @interface Deduction
 */
export interface Deduction {
    /**
     * 
     * @type {number}
     * @memberof Deduction
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Deduction
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Deduction
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Deduction
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Deduction
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Deduction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Deduction
     */
    'employee': number;
    /**
     * 
     * @type {number}
     * @memberof Deduction
     */
    'payslip': number;
    /**
     * 
     * @type {number}
     * @memberof Deduction
     */
    'loan_repayment'?: number | null;
}
/**
 * 
 * @export
 * @interface DeductionsList200Response
 */
export interface DeductionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeductionsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof DeductionsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeductionsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Deduction>}
     * @memberof DeductionsList200Response
     */
    'results': Array<Deduction>;
}
/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Department
     */
    'headed_by'?: number | null;
}
/**
 * 
 * @export
 * @interface DepartmentsList200Response
 */
export interface DepartmentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DepartmentsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof DepartmentsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DepartmentsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Department>}
     * @memberof DepartmentsList200Response
     */
    'results': Array<Department>;
}
/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'work_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'personal_email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'work_phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'personal_phone'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Employee
     */
    'address'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'profile_pic'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'gender': EmployeeGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'date_of_joining'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'date_of_leaving'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'salary'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'status'?: EmployeeStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'probation_status'?: EmployeeProbationStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'probation_period'?: number;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'taxid_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'pension_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'bank_code'?: EmployeeBankCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'bank_account_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'bank_account_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'bank_account_type'?: EmployeeBankAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'tax_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'pension_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'department'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'group'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Employee
     */
    'report_to'?: number | null;
}

export const EmployeeGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type EmployeeGenderEnum = typeof EmployeeGenderEnum[keyof typeof EmployeeGenderEnum];
export const EmployeeStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Left: 'left'
} as const;

export type EmployeeStatusEnum = typeof EmployeeStatusEnum[keyof typeof EmployeeStatusEnum];
export const EmployeeProbationStatusEnum = {
    Probation: 'probation',
    Confirmed: 'confirmed'
} as const;

export type EmployeeProbationStatusEnum = typeof EmployeeProbationStatusEnum[keyof typeof EmployeeProbationStatusEnum];
export const EmployeeBankCodeEnum = {
    _044: '044',
    _023: '023',
    _063: '063',
    _050: '050',
    _070: '070',
    _011: '011',
    _214: '214',
    _058: '058',
    _030: '030',
    _301: '301',
    _082: '082',
    _014: '014',
    _076: '076',
    _039: '039',
    _232: '232',
    _032: '032',
    _033: '033',
    _215: '215',
    _035: '035',
    _057: '057'
} as const;

export type EmployeeBankCodeEnum = typeof EmployeeBankCodeEnum[keyof typeof EmployeeBankCodeEnum];
export const EmployeeBankAccountTypeEnum = {
    Savings: 'savings',
    Current: 'current',
    Salary: 'salary'
} as const;

export type EmployeeBankAccountTypeEnum = typeof EmployeeBankAccountTypeEnum[keyof typeof EmployeeBankAccountTypeEnum];

/**
 * 
 * @export
 * @interface EmployeeGroup
 */
export interface EmployeeGroup {
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'base_salary'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'pension_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'tax_percent'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'loan_interest_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroup
     */
    'advance_interest_rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeGroup
     */
    'can_take_loan'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeGroup
     */
    'can_take_advance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroup
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroup
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface EmployeeGroupsList200Response
 */
export interface EmployeeGroupsList200Response {
    /**
     * 
     * @type {number}
     * @memberof EmployeeGroupsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroupsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeGroupsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EmployeeGroup>}
     * @memberof EmployeeGroupsList200Response
     */
    'results': Array<EmployeeGroup>;
}
/**
 * 
 * @export
 * @interface EmployeesList200Response
 */
export interface EmployeesList200Response {
    /**
     * 
     * @type {number}
     * @memberof EmployeesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof EmployeesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof EmployeesList200Response
     */
    'results': Array<Employee>;
}
/**
 * 
 * @export
 * @interface FilesList200Response
 */
export interface FilesList200Response {
    /**
     * 
     * @type {number}
     * @memberof FilesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof FilesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FilesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof FilesList200Response
     */
    'results': Array<any>;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'id'?: number;
    /**
     * 
     * @type {Array<Sharing>}
     * @memberof Folder
     */
    'sharing': Array<Sharing>;
    /**
     * 
     * @type {Owner}
     * @memberof Folder
     */
    'owner': Owner;
    /**
     * 
     * @type {object}
     * @memberof Folder
     */
    'meta_data': object;
    /**
     * 
     * @type {object}
     * @memberof Folder
     */
    'stats': object;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'is_module_folder'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'parent'?: number | null;
}
/**
 * 
 * @export
 * @interface FoldersList200Response
 */
export interface FoldersList200Response {
    /**
     * 
     * @type {number}
     * @memberof FoldersList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof FoldersList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoldersList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Folder>}
     * @memberof FoldersList200Response
     */
    'results': Array<Folder>;
}
/**
 * 
 * @export
 * @interface LeaveAndHoliday
 */
export interface LeaveAndHoliday {
    /**
     * 
     * @type {number}
     * @memberof LeaveAndHoliday
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'type': LeaveAndHolidayTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'pay_status': LeaveAndHolidayPayStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'status'?: LeaveAndHolidayStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'status_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHoliday
     */
    'end_date': string;
    /**
     * 
     * @type {number}
     * @memberof LeaveAndHoliday
     */
    'employee': number;
    /**
     * 
     * @type {number}
     * @memberof LeaveAndHoliday
     */
    'status_by'?: number | null;
}

export const LeaveAndHolidayTypeEnum = {
    Holiday: 'holiday',
    Leave: 'leave'
} as const;

export type LeaveAndHolidayTypeEnum = typeof LeaveAndHolidayTypeEnum[keyof typeof LeaveAndHolidayTypeEnum];
export const LeaveAndHolidayPayStatusEnum = {
    Paid: 'paid',
    Unpaid: 'unpaid'
} as const;

export type LeaveAndHolidayPayStatusEnum = typeof LeaveAndHolidayPayStatusEnum[keyof typeof LeaveAndHolidayPayStatusEnum];
export const LeaveAndHolidayStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Declined: 'declined'
} as const;

export type LeaveAndHolidayStatusEnum = typeof LeaveAndHolidayStatusEnum[keyof typeof LeaveAndHolidayStatusEnum];

/**
 * 
 * @export
 * @interface LeaveAndHolidaysList200Response
 */
export interface LeaveAndHolidaysList200Response {
    /**
     * 
     * @type {number}
     * @memberof LeaveAndHolidaysList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHolidaysList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaveAndHolidaysList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LeaveAndHoliday>}
     * @memberof LeaveAndHolidaysList200Response
     */
    'results': Array<LeaveAndHoliday>;
}
/**
 * 
 * @export
 * @interface LoanAndAdvance
 */
export interface LoanAndAdvance {
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'repayment_plans'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'is_paid_back'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'is_credited'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'amount_due'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'status_payment'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'status_payment_approval'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'type': LoanAndAdvanceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'interest_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'repayment_frequency'?: LoanAndAdvanceRepaymentFrequencyEnum;
    /**
     * Number of repayments to be made
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'repayment_step'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'status'?: LoanAndAdvanceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LoanAndAdvance
     */
    'status_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'employee': number;
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'status_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof LoanAndAdvance
     */
    'transaction'?: number | null;
}

export const LoanAndAdvanceTypeEnum = {
    Loan: 'loan',
    Advance: 'advance'
} as const;

export type LoanAndAdvanceTypeEnum = typeof LoanAndAdvanceTypeEnum[keyof typeof LoanAndAdvanceTypeEnum];
export const LoanAndAdvanceRepaymentFrequencyEnum = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    BiAnnually: 'bi-annually',
    Annually: 'annually'
} as const;

export type LoanAndAdvanceRepaymentFrequencyEnum = typeof LoanAndAdvanceRepaymentFrequencyEnum[keyof typeof LoanAndAdvanceRepaymentFrequencyEnum];
export const LoanAndAdvanceStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Declined: 'declined'
} as const;

export type LoanAndAdvanceStatusEnum = typeof LoanAndAdvanceStatusEnum[keyof typeof LoanAndAdvanceStatusEnum];

/**
 * 
 * @export
 * @interface LoansAndAdvancesList200Response
 */
export interface LoansAndAdvancesList200Response {
    /**
     * 
     * @type {number}
     * @memberof LoansAndAdvancesList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof LoansAndAdvancesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoansAndAdvancesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<LoanAndAdvance>}
     * @memberof LoansAndAdvancesList200Response
     */
    'results': Array<LoanAndAdvance>;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'id'?: number;
    /**
     * 
     * @type {Array<Sharing>}
     * @memberof ModelFile
     */
    'sharing': Array<Sharing>;
    /**
     * 
     * @type {Owner}
     * @memberof ModelFile
     */
    'owner': Owner;
    /**
     * 
     * @type {object}
     * @memberof ModelFile
     */
    'meta_data': object;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'file'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'is_document'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'folder'?: number | null;
}
/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * 
     * @type {number}
     * @memberof Owner
     */
    'id'?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof Owner
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'email'?: string;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Set<string>}
     * @memberof Owner
     */
    'groups'?: Set<string>;
}
/**
 * 
 * @export
 * @interface Payroll
 */
export interface Payroll {
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'pay_date': string;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'year'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'status'?: PayrollStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Payroll
     */
    'status_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'status_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'created_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'updated_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Payroll
     */
    'transaction'?: number | null;
}

export const PayrollStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Declined: 'declined'
} as const;

export type PayrollStatusEnum = typeof PayrollStatusEnum[keyof typeof PayrollStatusEnum];

/**
 * 
 * @export
 * @interface PayrollsList200Response
 */
export interface PayrollsList200Response {
    /**
     * 
     * @type {number}
     * @memberof PayrollsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PayrollsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayrollsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Payroll>}
     * @memberof PayrollsList200Response
     */
    'results': Array<Payroll>;
}
/**
 * 
 * @export
 * @interface Payslip
 */
export interface Payslip {
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'earnings'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'deductions'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'total_earning'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'total_deduction'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'net_pay'?: string;
    /**
     * 
     * @type {object}
     * @memberof Payslip
     */
    'payment_info'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'pay_status'?: PayslipPayStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payslip
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    'employee': number;
    /**
     * 
     * @type {number}
     * @memberof Payslip
     */
    'payroll': number;
}

export const PayslipPayStatusEnum = {
    Paid: 'paid',
    Unpaid: 'unpaid'
} as const;

export type PayslipPayStatusEnum = typeof PayslipPayStatusEnum[keyof typeof PayslipPayStatusEnum];

/**
 * 
 * @export
 * @interface PayslipsList200Response
 */
export interface PayslipsList200Response {
    /**
     * 
     * @type {number}
     * @memberof PayslipsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PayslipsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayslipsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Payslip>}
     * @memberof PayslipsList200Response
     */
    'results': Array<Payslip>;
}
/**
 * 
 * @export
 * @interface ProfiLossForm
 */
export interface ProfiLossForm {
    /**
     * Start date
     * @type {string}
     * @memberof ProfiLossForm
     */
    'start_date': string;
    /**
     * End date
     * @type {string}
     * @memberof ProfiLossForm
     */
    'end_date': string;
}
/**
 * 
 * @export
 * @interface Sharing
 */
export interface Sharing {
    /**
     * 
     * @type {number}
     * @memberof Sharing
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Sharing
     */
    'can_read'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sharing
     */
    'can_edit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sharing
     */
    'can_delete'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Sharing
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof Sharing
     */
    'file'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Sharing
     */
    'folder'?: number | null;
}
/**
 * 
 * @export
 * @interface Training
 */
export interface Training {
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Training
     */
    'is_paid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'end_date': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'review': string;
    /**
     * 
     * @type {boolean}
     * @memberof Training
     */
    'has_certificate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'certificate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'status'?: TrainingStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'status_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'pay_status'?: TrainingPayStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'employee': number;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'status_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'transaction'?: number | null;
}

export const TrainingStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Declined: 'declined'
} as const;

export type TrainingStatusEnum = typeof TrainingStatusEnum[keyof typeof TrainingStatusEnum];
export const TrainingPayStatusEnum = {
    Paid: 'paid',
    Unpaid: 'unpaid'
} as const;

export type TrainingPayStatusEnum = typeof TrainingPayStatusEnum[keyof typeof TrainingPayStatusEnum];

/**
 * 
 * @export
 * @interface TrainingsList200Response
 */
export interface TrainingsList200Response {
    /**
     * 
     * @type {number}
     * @memberof TrainingsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof TrainingsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrainingsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Training>}
     * @memberof TrainingsList200Response
     */
    'results': Array<Training>;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'logs'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'approval_status'?: TransactionApprovalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'approved_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'status'?: TransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'paid_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'type'?: TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'priority'?: TransactionPriorityEnum;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    'meta_data'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'category'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'created_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'approved_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'status_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'folder'?: number | null;
}

export const TransactionApprovalStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Declined: 'declined'
} as const;

export type TransactionApprovalStatusEnum = typeof TransactionApprovalStatusEnum[keyof typeof TransactionApprovalStatusEnum];
export const TransactionStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Unpaid: 'unpaid'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];
export const TransactionTypeEnum = {
    Debit: 'debit',
    Credit: 'credit'
} as const;

export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];
export const TransactionPriorityEnum = {
    Urgent: 'urgent',
    Normal: 'normal',
    High: 'high',
    Low: 'low'
} as const;

export type TransactionPriorityEnum = typeof TransactionPriorityEnum[keyof typeof TransactionPriorityEnum];

/**
 * 
 * @export
 * @interface TransactionsExpenseList200Response
 */
export interface TransactionsExpenseList200Response {
    /**
     * 
     * @type {number}
     * @memberof TransactionsExpenseList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionsExpenseList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionsExpenseList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ProfiLossForm>}
     * @memberof TransactionsExpenseList200Response
     */
    'results': Array<ProfiLossForm>;
}
/**
 * 
 * @export
 * @interface TransactionsList200Response
 */
export interface TransactionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof TransactionsList200Response
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionsList200Response
     */
    'results': Array<Transaction>;
}

/**
 * AllowancesApi - axios parameter creator
 * @export
 */
export const AllowancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesCreate: async (data: Allowance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('allowancesCreate', 'data', data)
            const localVarPath = `/allowances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('allowancesDelete', 'id', id)
            const localVarPath = `/allowances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allowances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesPartialUpdate: async (id: number, data: Allowance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('allowancesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('allowancesPartialUpdate', 'data', data)
            const localVarPath = `/allowances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('allowancesRead', 'id', id)
            const localVarPath = `/allowances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesUpdate: async (id: number, data: Allowance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('allowancesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('allowancesUpdate', 'data', data)
            const localVarPath = `/allowances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllowancesApi - functional programming interface
 * @export
 */
export const AllowancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllowancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesCreate(data: Allowance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowancesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesPartialUpdate(id: number, data: Allowance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesUpdate(id: number, data: Allowance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AllowancesApi - factory interface
 * @export
 */
export const AllowancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllowancesApiFp(configuration)
    return {
        /**
         * 
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesCreate(data: Allowance, options?: any): AxiosPromise<Allowance> {
            return localVarFp.allowancesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.allowancesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesList(page?: number, pageSize?: number, options?: any): AxiosPromise<AllowancesList200Response> {
            return localVarFp.allowancesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesPartialUpdate(id: number, data: Allowance, options?: any): AxiosPromise<Allowance> {
            return localVarFp.allowancesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesRead(id: number, options?: any): AxiosPromise<Allowance> {
            return localVarFp.allowancesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this allowance.
         * @param {Allowance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesUpdate(id: number, data: Allowance, options?: any): AxiosPromise<Allowance> {
            return localVarFp.allowancesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllowancesApi - object-oriented interface
 * @export
 * @class AllowancesApi
 * @extends {BaseAPI}
 */
export class AllowancesApi extends BaseAPI {
    /**
     * 
     * @param {Allowance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesCreate(data: Allowance, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this allowance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesDelete(id: number, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this allowance.
     * @param {Allowance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesPartialUpdate(id: number, data: Allowance, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this allowance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesRead(id: number, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this allowance.
     * @param {Allowance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public allowancesUpdate(id: number, data: Allowance, options?: AxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).allowancesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsCreate: async (data: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('assetsCreate', 'data', data)
            const localVarPath = `/assets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsDelete', 'id', id)
            const localVarPath = `/assets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsDocuments: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsDocuments', 'id', id)
            const localVarPath = `/assets/{id}/documents/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsLogs: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsLogs', 'id', id)
            const localVarPath = `/assets/{id}/logs/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsMaintenance: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsMaintenance', 'id', id)
            const localVarPath = `/assets/{id}/maintenance/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsPartialUpdate: async (id: number, data: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('assetsPartialUpdate', 'data', data)
            const localVarPath = `/assets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsRead', 'id', id)
            const localVarPath = `/assets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsTransactions: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsTransactions', 'id', id)
            const localVarPath = `/assets/{id}/transactions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsUpdate: async (id: number, data: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('assetsUpdate', 'data', data)
            const localVarPath = `/assets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsUsage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assetsUsage', 'id', id)
            const localVarPath = `/assets/{id}/usage/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsCreate(data: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsDocuments(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsDocuments(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsLogs(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsLogs(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsMaintenance(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsMaintenance(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsPartialUpdate(id: number, data: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsTransactions(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsTransactions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsUpdate(id: number, data: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetsUsage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetsUsage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * 
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsCreate(data: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.assetsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsDocuments(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsDocuments(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsList(page?: number, pageSize?: number, options?: any): AxiosPromise<AssetsList200Response> {
            return localVarFp.assetsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsLogs(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsLogs(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsMaintenance(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsMaintenance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsPartialUpdate(id: number, data: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsRead(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsTransactions(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsTransactions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {Asset} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsUpdate(id: number, data: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetsUsage(id: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.assetsUsage(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @param {Asset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsCreate(data: Asset, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsDelete(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsDocuments(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsDocuments(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsLogs(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsLogs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsMaintenance(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsMaintenance(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {Asset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsPartialUpdate(id: number, data: Asset, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsRead(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsTransactions(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsTransactions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {Asset} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsUpdate(id: number, data: Asset, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public assetsUsage(id: number, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).assetsUsage(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetCyclesApi - axios parameter creator
 * @export
 */
export const BudgetCyclesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesCreate: async (data: BudgetCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetCyclesCreate', 'data', data)
            const localVarPath = `/budget_cycles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetCyclesDelete', 'id', id)
            const localVarPath = `/budget_cycles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesGetBudgets: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetCyclesGetBudgets', 'id', id)
            const localVarPath = `/budget_cycles/{id}/get_budgets/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/budget_cycles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesPartialUpdate: async (id: number, data: BudgetCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetCyclesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetCyclesPartialUpdate', 'data', data)
            const localVarPath = `/budget_cycles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetCyclesRead', 'id', id)
            const localVarPath = `/budget_cycles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesUpdate: async (id: number, data: BudgetCycle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetCyclesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetCyclesUpdate', 'data', data)
            const localVarPath = `/budget_cycles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetCyclesApi - functional programming interface
 * @export
 */
export const BudgetCyclesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetCyclesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesCreate(data: BudgetCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesGetBudgets(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesGetBudgets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetCyclesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesPartialUpdate(id: number, data: BudgetCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetCyclesUpdate(id: number, data: BudgetCycle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetCyclesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetCyclesApi - factory interface
 * @export
 */
export const BudgetCyclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetCyclesApiFp(configuration)
    return {
        /**
         * 
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesCreate(data: BudgetCycle, options?: any): AxiosPromise<BudgetCycle> {
            return localVarFp.budgetCyclesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.budgetCyclesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesGetBudgets(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.budgetCyclesGetBudgets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesList(page?: number, pageSize?: number, options?: any): AxiosPromise<BudgetCyclesList200Response> {
            return localVarFp.budgetCyclesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesPartialUpdate(id: number, data: BudgetCycle, options?: any): AxiosPromise<BudgetCycle> {
            return localVarFp.budgetCyclesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesRead(id: number, options?: any): AxiosPromise<BudgetCycle> {
            return localVarFp.budgetCyclesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget cycle.
         * @param {BudgetCycle} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetCyclesUpdate(id: number, data: BudgetCycle, options?: any): AxiosPromise<BudgetCycle> {
            return localVarFp.budgetCyclesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetCyclesApi - object-oriented interface
 * @export
 * @class BudgetCyclesApi
 * @extends {BaseAPI}
 */
export class BudgetCyclesApi extends BaseAPI {
    /**
     * 
     * @param {BudgetCycle} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesCreate(data: BudgetCycle, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget cycle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesDelete(id: number, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget cycle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesGetBudgets(id: number, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesGetBudgets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget cycle.
     * @param {BudgetCycle} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesPartialUpdate(id: number, data: BudgetCycle, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget cycle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesRead(id: number, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget cycle.
     * @param {BudgetCycle} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetCyclesApi
     */
    public budgetCyclesUpdate(id: number, data: BudgetCycle, options?: AxiosRequestConfig) {
        return BudgetCyclesApiFp(this.configuration).budgetCyclesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsCreate: async (data: Budget, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetsCreate', 'data', data)
            const localVarPath = `/budgets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetsDelete', 'id', id)
            const localVarPath = `/budgets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsGetTransactions: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetsGetTransactions', 'id', id)
            const localVarPath = `/budgets/{id}/get_transactions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/budgets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsPartialUpdate: async (id: number, data: Budget, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetsPartialUpdate', 'data', data)
            const localVarPath = `/budgets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetsRead', 'id', id)
            const localVarPath = `/budgets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsUpdate: async (id: number, data: Budget, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('budgetsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('budgetsUpdate', 'data', data)
            const localVarPath = `/budgets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsCreate(data: Budget, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsGetTransactions(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsGetTransactions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsPartialUpdate(id: number, data: Budget, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async budgetsUpdate(id: number, data: Budget, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.budgetsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * 
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsCreate(data: Budget, options?: any): AxiosPromise<Budget> {
            return localVarFp.budgetsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.budgetsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsGetTransactions(id: number, options?: any): AxiosPromise<object> {
            return localVarFp.budgetsGetTransactions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsList(page?: number, pageSize?: number, options?: any): AxiosPromise<BudgetsList200Response> {
            return localVarFp.budgetsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsPartialUpdate(id: number, data: Budget, options?: any): AxiosPromise<Budget> {
            return localVarFp.budgetsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsRead(id: number, options?: any): AxiosPromise<Budget> {
            return localVarFp.budgetsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this budget.
         * @param {Budget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        budgetsUpdate(id: number, data: Budget, options?: any): AxiosPromise<Budget> {
            return localVarFp.budgetsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * 
     * @param {Budget} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsCreate(data: Budget, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsDelete(id: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsGetTransactions(id: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsGetTransactions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget.
     * @param {Budget} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsPartialUpdate(id: number, data: Budget, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsRead(id: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this budget.
     * @param {Budget} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public budgetsUpdate(id: number, data: Budget, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).budgetsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate: async (data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesCreate', 'data', data)
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesDelete', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate: async (id: number, data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesPartialUpdate', 'data', data)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesRead', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate: async (id: number, data: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoriesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('categoriesUpdate', 'data', data)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesCreate(data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesPartialUpdate(id: number, data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesUpdate(id: number, data: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesCreate(data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.categoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesList(page?: number, pageSize?: number, options?: any): AxiosPromise<CategoriesList200Response> {
            return localVarFp.categoriesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesPartialUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesRead(id: number, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this category.
         * @param {Category} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesUpdate(id: number, data: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.categoriesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesCreate(data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesDelete(id: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesPartialUpdate(id: number, data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesRead(id: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this category.
     * @param {Category} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public categoriesUpdate(id: number, data: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).categoriesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeductionsApi - axios parameter creator
 * @export
 */
export const DeductionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsCreate: async (data: Deduction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('deductionsCreate', 'data', data)
            const localVarPath = `/deductions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deductionsDelete', 'id', id)
            const localVarPath = `/deductions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deductions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsPartialUpdate: async (id: number, data: Deduction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deductionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('deductionsPartialUpdate', 'data', data)
            const localVarPath = `/deductions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deductionsRead', 'id', id)
            const localVarPath = `/deductions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsUpdate: async (id: number, data: Deduction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deductionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('deductionsUpdate', 'data', data)
            const localVarPath = `/deductions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeductionsApi - functional programming interface
 * @export
 */
export const DeductionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeductionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsCreate(data: Deduction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deduction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeductionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsPartialUpdate(id: number, data: Deduction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deduction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deduction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deductionsUpdate(id: number, data: Deduction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deduction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deductionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeductionsApi - factory interface
 * @export
 */
export const DeductionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeductionsApiFp(configuration)
    return {
        /**
         * 
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsCreate(data: Deduction, options?: any): AxiosPromise<Deduction> {
            return localVarFp.deductionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deductionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsList(page?: number, pageSize?: number, options?: any): AxiosPromise<DeductionsList200Response> {
            return localVarFp.deductionsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsPartialUpdate(id: number, data: Deduction, options?: any): AxiosPromise<Deduction> {
            return localVarFp.deductionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsRead(id: number, options?: any): AxiosPromise<Deduction> {
            return localVarFp.deductionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this deduction.
         * @param {Deduction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deductionsUpdate(id: number, data: Deduction, options?: any): AxiosPromise<Deduction> {
            return localVarFp.deductionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeductionsApi - object-oriented interface
 * @export
 * @class DeductionsApi
 * @extends {BaseAPI}
 */
export class DeductionsApi extends BaseAPI {
    /**
     * 
     * @param {Deduction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsCreate(data: Deduction, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this deduction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsDelete(id: number, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this deduction.
     * @param {Deduction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsPartialUpdate(id: number, data: Deduction, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this deduction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsRead(id: number, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this deduction.
     * @param {Deduction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeductionsApi
     */
    public deductionsUpdate(id: number, data: Deduction, options?: AxiosRequestConfig) {
        return DeductionsApiFp(this.configuration).deductionsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsCreate: async (data: Department, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('departmentsCreate', 'data', data)
            const localVarPath = `/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsDelete', 'id', id)
            const localVarPath = `/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsPartialUpdate: async (id: number, data: Department, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('departmentsPartialUpdate', 'data', data)
            const localVarPath = `/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRead', 'id', id)
            const localVarPath = `/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsUpdate: async (id: number, data: Department, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('departmentsUpdate', 'data', data)
            const localVarPath = `/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsCreate(data: Department, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsPartialUpdate(id: number, data: Department, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async departmentsUpdate(id: number, data: Department, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.departmentsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsCreate(data: Department, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.departmentsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsList(page?: number, pageSize?: number, options?: any): AxiosPromise<DepartmentsList200Response> {
            return localVarFp.departmentsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsPartialUpdate(id: number, data: Department, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRead(id: number, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this department.
         * @param {Department} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsUpdate(id: number, data: Department, options?: any): AxiosPromise<Department> {
            return localVarFp.departmentsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * 
     * @param {Department} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsCreate(data: Department, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this department.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsDelete(id: number, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this department.
     * @param {Department} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsPartialUpdate(id: number, data: Department, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this department.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsRead(id: number, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this department.
     * @param {Department} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    public departmentsUpdate(id: number, data: Department, options?: AxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).departmentsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmployeeGroupsApi - axios parameter creator
 * @export
 */
export const EmployeeGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsCreate: async (data: EmployeeGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeeGroupsCreate', 'data', data)
            const localVarPath = `/employee-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeGroupsDelete', 'id', id)
            const localVarPath = `/employee-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employee-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsPartialUpdate: async (id: number, data: EmployeeGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeeGroupsPartialUpdate', 'data', data)
            const localVarPath = `/employee-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeGroupsRead', 'id', id)
            const localVarPath = `/employee-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsUpdate: async (id: number, data: EmployeeGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeeGroupsUpdate', 'data', data)
            const localVarPath = `/employee-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeGroupsApi - functional programming interface
 * @export
 */
export const EmployeeGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeeGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsCreate(data: EmployeeGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeGroupsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsPartialUpdate(id: number, data: EmployeeGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeGroupsUpdate(id: number, data: EmployeeGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeeGroupsApi - factory interface
 * @export
 */
export const EmployeeGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeeGroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsCreate(data: EmployeeGroup, options?: any): AxiosPromise<EmployeeGroup> {
            return localVarFp.employeeGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.employeeGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsList(page?: number, pageSize?: number, options?: any): AxiosPromise<EmployeeGroupsList200Response> {
            return localVarFp.employeeGroupsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsPartialUpdate(id: number, data: EmployeeGroup, options?: any): AxiosPromise<EmployeeGroup> {
            return localVarFp.employeeGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsRead(id: number, options?: any): AxiosPromise<EmployeeGroup> {
            return localVarFp.employeeGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee group.
         * @param {EmployeeGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeGroupsUpdate(id: number, data: EmployeeGroup, options?: any): AxiosPromise<EmployeeGroup> {
            return localVarFp.employeeGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeeGroupsApi - object-oriented interface
 * @export
 * @class EmployeeGroupsApi
 * @extends {BaseAPI}
 */
export class EmployeeGroupsApi extends BaseAPI {
    /**
     * 
     * @param {EmployeeGroup} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsCreate(data: EmployeeGroup, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsDelete(id: number, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee group.
     * @param {EmployeeGroup} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsPartialUpdate(id: number, data: EmployeeGroup, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsRead(id: number, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee group.
     * @param {EmployeeGroup} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeGroupsApi
     */
    public employeeGroupsUpdate(id: number, data: EmployeeGroup, options?: AxiosRequestConfig) {
        return EmployeeGroupsApiFp(this.configuration).employeeGroupsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmployeesApi - axios parameter creator
 * @export
 */
export const EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesCreate: async (data: Employee, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeesCreate', 'data', data)
            const localVarPath = `/employees/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeesDelete', 'id', id)
            const localVarPath = `/employees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPartialUpdate: async (id: number, data: Employee, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeesPartialUpdate', 'data', data)
            const localVarPath = `/employees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeesRead', 'id', id)
            const localVarPath = `/employees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesUpdate: async (id: number, data: Employee, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('employeesUpdate', 'data', data)
            const localVarPath = `/employees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeesApi - functional programming interface
 * @export
 */
export const EmployeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesCreate(data: Employee, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Employee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesPartialUpdate(id: number, data: Employee, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Employee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Employee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesUpdate(id: number, data: Employee, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Employee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeesApi - factory interface
 * @export
 */
export const EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeesApiFp(configuration)
    return {
        /**
         * 
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesCreate(data: Employee, options?: any): AxiosPromise<Employee> {
            return localVarFp.employeesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.employeesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesList(page?: number, pageSize?: number, options?: any): AxiosPromise<EmployeesList200Response> {
            return localVarFp.employeesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPartialUpdate(id: number, data: Employee, options?: any): AxiosPromise<Employee> {
            return localVarFp.employeesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesRead(id: number, options?: any): AxiosPromise<Employee> {
            return localVarFp.employeesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this employee.
         * @param {Employee} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesUpdate(id: number, data: Employee, options?: any): AxiosPromise<Employee> {
            return localVarFp.employeesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeesApi - object-oriented interface
 * @export
 * @class EmployeesApi
 * @extends {BaseAPI}
 */
export class EmployeesApi extends BaseAPI {
    /**
     * 
     * @param {Employee} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesCreate(data: Employee, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesDelete(id: number, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee.
     * @param {Employee} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesPartialUpdate(id: number, data: Employee, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesRead(id: number, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this employee.
     * @param {Employee} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesUpdate(id: number, data: Employee, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesCreate: async (data: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('filesCreate', 'data', data)
            const localVarPath = `/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesDelete', 'id', id)
            const localVarPath = `/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate: async (id: number, data: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('filesPartialUpdate', 'data', data)
            const localVarPath = `/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesRead', 'id', id)
            const localVarPath = `/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUpdate: async (id: number, data: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('filesUpdate', 'data', data)
            const localVarPath = `/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesCreate(data: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPartialUpdate(id: number, data: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesUpdate(id: number, data: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesCreate(data: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.filesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList(page?: number, pageSize?: number, options?: any): AxiosPromise<FilesList200Response> {
            return localVarFp.filesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate(id: number, data: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRead(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.filesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUpdate(id: number, data: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {ModelFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesCreate(data: ModelFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesDelete(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {ModelFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPartialUpdate(id: number, data: ModelFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesRead(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {ModelFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesUpdate(id: number, data: ModelFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersContent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foldersContent', 'id', id)
            const localVarPath = `/folders/{id}/content/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersCreate: async (data: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('foldersCreate', 'data', data)
            const localVarPath = `/folders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foldersDelete', 'id', id)
            const localVarPath = `/folders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersPartialUpdate: async (id: number, data: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foldersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('foldersPartialUpdate', 'data', data)
            const localVarPath = `/folders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foldersRead', 'id', id)
            const localVarPath = `/folders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersUpdate: async (id: number, data: Folder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foldersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('foldersUpdate', 'data', data)
            const localVarPath = `/folders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersContent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersContent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersCreate(data: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoldersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersPartialUpdate(id: number, data: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foldersUpdate(id: number, data: Folder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foldersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersContent(id: number, options?: any): AxiosPromise<Folder> {
            return localVarFp.foldersContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersCreate(data: Folder, options?: any): AxiosPromise<Folder> {
            return localVarFp.foldersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.foldersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersList(page?: number, pageSize?: number, options?: any): AxiosPromise<FoldersList200Response> {
            return localVarFp.foldersList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersPartialUpdate(id: number, data: Folder, options?: any): AxiosPromise<Folder> {
            return localVarFp.foldersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersRead(id: number, options?: any): AxiosPromise<Folder> {
            return localVarFp.foldersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this folder.
         * @param {Folder} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foldersUpdate(id: number, data: Folder, options?: any): AxiosPromise<Folder> {
            return localVarFp.foldersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersContent(id: number, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Folder} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersCreate(data: Folder, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersDelete(id: number, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this folder.
     * @param {Folder} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersPartialUpdate(id: number, data: Folder, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this folder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersRead(id: number, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this folder.
     * @param {Folder} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public foldersUpdate(id: number, data: Folder, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).foldersUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeaveAndHolidaysApi - axios parameter creator
 * @export
 */
export const LeaveAndHolidaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysApprove: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysApprove', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('leaveAndHolidaysApprove', 'data', data)
            const localVarPath = `/leave-and-holidays/{id}/approve/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysCreate: async (data: LeaveAndHoliday, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('leaveAndHolidaysCreate', 'data', data)
            const localVarPath = `/leave-and-holidays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysDecline: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysDecline', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('leaveAndHolidaysDecline', 'data', data)
            const localVarPath = `/leave-and-holidays/{id}/decline/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysDelete', 'id', id)
            const localVarPath = `/leave-and-holidays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leave-and-holidays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysPartialUpdate: async (id: number, data: LeaveAndHoliday, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('leaveAndHolidaysPartialUpdate', 'data', data)
            const localVarPath = `/leave-and-holidays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysRead', 'id', id)
            const localVarPath = `/leave-and-holidays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysUpdate: async (id: number, data: LeaveAndHoliday, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveAndHolidaysUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('leaveAndHolidaysUpdate', 'data', data)
            const localVarPath = `/leave-and-holidays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaveAndHolidaysApi - functional programming interface
 * @export
 */
export const LeaveAndHolidaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaveAndHolidaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysApprove(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysApprove(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysCreate(data: LeaveAndHoliday, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAndHoliday>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysDecline(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysDecline(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAndHolidaysList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysPartialUpdate(id: number, data: LeaveAndHoliday, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAndHoliday>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAndHoliday>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveAndHolidaysUpdate(id: number, data: LeaveAndHoliday, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAndHoliday>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveAndHolidaysUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeaveAndHolidaysApi - factory interface
 * @export
 */
export const LeaveAndHolidaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaveAndHolidaysApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysApprove(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.leaveAndHolidaysApprove(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysCreate(data: LeaveAndHoliday, options?: any): AxiosPromise<LeaveAndHoliday> {
            return localVarFp.leaveAndHolidaysCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysDecline(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.leaveAndHolidaysDecline(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.leaveAndHolidaysDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysList(page?: number, pageSize?: number, options?: any): AxiosPromise<LeaveAndHolidaysList200Response> {
            return localVarFp.leaveAndHolidaysList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysPartialUpdate(id: number, data: LeaveAndHoliday, options?: any): AxiosPromise<LeaveAndHoliday> {
            return localVarFp.leaveAndHolidaysPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysRead(id: number, options?: any): AxiosPromise<LeaveAndHoliday> {
            return localVarFp.leaveAndHolidaysRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this leave and holiday.
         * @param {LeaveAndHoliday} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveAndHolidaysUpdate(id: number, data: LeaveAndHoliday, options?: any): AxiosPromise<LeaveAndHoliday> {
            return localVarFp.leaveAndHolidaysUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaveAndHolidaysApi - object-oriented interface
 * @export
 * @class LeaveAndHolidaysApi
 * @extends {BaseAPI}
 */
export class LeaveAndHolidaysApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysApprove(id: number, data: object, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysApprove(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LeaveAndHoliday} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysCreate(data: LeaveAndHoliday, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysDecline(id: number, data: object, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysDecline(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysDelete(id: number, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {LeaveAndHoliday} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysPartialUpdate(id: number, data: LeaveAndHoliday, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysRead(id: number, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this leave and holiday.
     * @param {LeaveAndHoliday} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaveAndHolidaysApi
     */
    public leaveAndHolidaysUpdate(id: number, data: LeaveAndHoliday, options?: AxiosRequestConfig) {
        return LeaveAndHolidaysApiFp(this.configuration).leaveAndHolidaysUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoansAndAdvancesApi - axios parameter creator
 * @export
 */
export const LoansAndAdvancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesApprove: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesApprove', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('loansAndAdvancesApprove', 'data', data)
            const localVarPath = `/loans-and-advances/{id}/approve/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesCreate: async (data: LoanAndAdvance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('loansAndAdvancesCreate', 'data', data)
            const localVarPath = `/loans-and-advances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesDecline: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesDecline', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('loansAndAdvancesDecline', 'data', data)
            const localVarPath = `/loans-and-advances/{id}/decline/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesDelete', 'id', id)
            const localVarPath = `/loans-and-advances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/loans-and-advances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesPartialUpdate: async (id: number, data: LoanAndAdvance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('loansAndAdvancesPartialUpdate', 'data', data)
            const localVarPath = `/loans-and-advances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesRead', 'id', id)
            const localVarPath = `/loans-and-advances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesUpdate: async (id: number, data: LoanAndAdvance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loansAndAdvancesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('loansAndAdvancesUpdate', 'data', data)
            const localVarPath = `/loans-and-advances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoansAndAdvancesApi - functional programming interface
 * @export
 */
export const LoansAndAdvancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoansAndAdvancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesApprove(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesApprove(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesCreate(data: LoanAndAdvance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanAndAdvance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesDecline(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesDecline(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoansAndAdvancesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesPartialUpdate(id: number, data: LoanAndAdvance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanAndAdvance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanAndAdvance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loansAndAdvancesUpdate(id: number, data: LoanAndAdvance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanAndAdvance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loansAndAdvancesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoansAndAdvancesApi - factory interface
 * @export
 */
export const LoansAndAdvancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoansAndAdvancesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesApprove(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.loansAndAdvancesApprove(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesCreate(data: LoanAndAdvance, options?: any): AxiosPromise<LoanAndAdvance> {
            return localVarFp.loansAndAdvancesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesDecline(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.loansAndAdvancesDecline(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.loansAndAdvancesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesList(page?: number, pageSize?: number, options?: any): AxiosPromise<LoansAndAdvancesList200Response> {
            return localVarFp.loansAndAdvancesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesPartialUpdate(id: number, data: LoanAndAdvance, options?: any): AxiosPromise<LoanAndAdvance> {
            return localVarFp.loansAndAdvancesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesRead(id: number, options?: any): AxiosPromise<LoanAndAdvance> {
            return localVarFp.loansAndAdvancesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this loan and advance.
         * @param {LoanAndAdvance} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loansAndAdvancesUpdate(id: number, data: LoanAndAdvance, options?: any): AxiosPromise<LoanAndAdvance> {
            return localVarFp.loansAndAdvancesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoansAndAdvancesApi - object-oriented interface
 * @export
 * @class LoansAndAdvancesApi
 * @extends {BaseAPI}
 */
export class LoansAndAdvancesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesApprove(id: number, data: object, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesApprove(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoanAndAdvance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesCreate(data: LoanAndAdvance, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesDecline(id: number, data: object, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesDecline(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesDelete(id: number, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {LoanAndAdvance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesPartialUpdate(id: number, data: LoanAndAdvance, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesRead(id: number, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this loan and advance.
     * @param {LoanAndAdvance} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansAndAdvancesApi
     */
    public loansAndAdvancesUpdate(id: number, data: LoanAndAdvance, options?: AxiosRequestConfig) {
        return LoansAndAdvancesApiFp(this.configuration).loansAndAdvancesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayrollsApi - axios parameter creator
 * @export
 */
export const PayrollsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsApprove: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsApprove', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payrollsApprove', 'data', data)
            const localVarPath = `/payrolls/{id}/approve/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsCreate: async (data: Payroll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payrollsCreate', 'data', data)
            const localVarPath = `/payrolls/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsDecline: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsDecline', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payrollsDecline', 'data', data)
            const localVarPath = `/payrolls/{id}/decline/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsDelete', 'id', id)
            const localVarPath = `/payrolls/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payrolls/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsPartialUpdate: async (id: number, data: Payroll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payrollsPartialUpdate', 'data', data)
            const localVarPath = `/payrolls/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsRead', 'id', id)
            const localVarPath = `/payrolls/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsUpdate: async (id: number, data: Payroll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payrollsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payrollsUpdate', 'data', data)
            const localVarPath = `/payrolls/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayrollsApi - functional programming interface
 * @export
 */
export const PayrollsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayrollsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsApprove(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsApprove(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsCreate(data: Payroll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsDecline(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsDecline(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayrollsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsPartialUpdate(id: number, data: Payroll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payrollsUpdate(id: number, data: Payroll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payroll>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payrollsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayrollsApi - factory interface
 * @export
 */
export const PayrollsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayrollsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsApprove(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.payrollsApprove(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsCreate(data: Payroll, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsDecline(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.payrollsDecline(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.payrollsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsList(page?: number, pageSize?: number, options?: any): AxiosPromise<PayrollsList200Response> {
            return localVarFp.payrollsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsPartialUpdate(id: number, data: Payroll, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsRead(id: number, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payroll.
         * @param {Payroll} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payrollsUpdate(id: number, data: Payroll, options?: any): AxiosPromise<Payroll> {
            return localVarFp.payrollsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayrollsApi - object-oriented interface
 * @export
 * @class PayrollsApi
 * @extends {BaseAPI}
 */
export class PayrollsApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsApprove(id: number, data: object, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsApprove(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Payroll} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsCreate(data: Payroll, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsDecline(id: number, data: object, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsDecline(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsDelete(id: number, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {Payroll} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsPartialUpdate(id: number, data: Payroll, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsRead(id: number, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payroll.
     * @param {Payroll} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayrollsApi
     */
    public payrollsUpdate(id: number, data: Payroll, options?: AxiosRequestConfig) {
        return PayrollsApiFp(this.configuration).payrollsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayslipsApi - axios parameter creator
 * @export
 */
export const PayslipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsCreate: async (data: Payslip, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payslipsCreate', 'data', data)
            const localVarPath = `/payslips/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payslipsDelete', 'id', id)
            const localVarPath = `/payslips/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payslips/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsPartialUpdate: async (id: number, data: Payslip, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payslipsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payslipsPartialUpdate', 'data', data)
            const localVarPath = `/payslips/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payslipsRead', 'id', id)
            const localVarPath = `/payslips/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsUpdate: async (id: number, data: Payslip, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payslipsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('payslipsUpdate', 'data', data)
            const localVarPath = `/payslips/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayslipsApi - functional programming interface
 * @export
 */
export const PayslipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayslipsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsCreate(data: Payslip, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payslip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayslipsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsPartialUpdate(id: number, data: Payslip, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payslip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payslip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payslipsUpdate(id: number, data: Payslip, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payslip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payslipsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayslipsApi - factory interface
 * @export
 */
export const PayslipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayslipsApiFp(configuration)
    return {
        /**
         * 
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsCreate(data: Payslip, options?: any): AxiosPromise<Payslip> {
            return localVarFp.payslipsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.payslipsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsList(page?: number, pageSize?: number, options?: any): AxiosPromise<PayslipsList200Response> {
            return localVarFp.payslipsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsPartialUpdate(id: number, data: Payslip, options?: any): AxiosPromise<Payslip> {
            return localVarFp.payslipsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsRead(id: number, options?: any): AxiosPromise<Payslip> {
            return localVarFp.payslipsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this payslip.
         * @param {Payslip} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payslipsUpdate(id: number, data: Payslip, options?: any): AxiosPromise<Payslip> {
            return localVarFp.payslipsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayslipsApi - object-oriented interface
 * @export
 * @class PayslipsApi
 * @extends {BaseAPI}
 */
export class PayslipsApi extends BaseAPI {
    /**
     * 
     * @param {Payslip} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsCreate(data: Payslip, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payslip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsDelete(id: number, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payslip.
     * @param {Payslip} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsPartialUpdate(id: number, data: Payslip, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payslip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsRead(id: number, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this payslip.
     * @param {Payslip} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayslipsApi
     */
    public payslipsUpdate(id: number, data: Payslip, options?: AxiosRequestConfig) {
        return PayslipsApiFp(this.configuration).payslipsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainingsApi - axios parameter creator
 * @export
 */
export const TrainingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsApprove: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsApprove', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('trainingsApprove', 'data', data)
            const localVarPath = `/trainings/{id}/approve/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsCreate: async (data: Training, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('trainingsCreate', 'data', data)
            const localVarPath = `/trainings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsDecline: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsDecline', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('trainingsDecline', 'data', data)
            const localVarPath = `/trainings/{id}/decline/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsDelete', 'id', id)
            const localVarPath = `/trainings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trainings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsPartialUpdate: async (id: number, data: Training, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('trainingsPartialUpdate', 'data', data)
            const localVarPath = `/trainings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsRead', 'id', id)
            const localVarPath = `/trainings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsUpdate: async (id: number, data: Training, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('trainingsUpdate', 'data', data)
            const localVarPath = `/trainings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingsApi - functional programming interface
 * @export
 */
export const TrainingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsApprove(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsApprove(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsCreate(data: Training, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Training>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsDecline(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsDecline(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsPartialUpdate(id: number, data: Training, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Training>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Training>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingsUpdate(id: number, data: Training, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Training>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainingsApi - factory interface
 * @export
 */
export const TrainingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainingsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsApprove(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.trainingsApprove(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsCreate(data: Training, options?: any): AxiosPromise<Training> {
            return localVarFp.trainingsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsDecline(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.trainingsDecline(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.trainingsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsList(page?: number, pageSize?: number, options?: any): AxiosPromise<TrainingsList200Response> {
            return localVarFp.trainingsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsPartialUpdate(id: number, data: Training, options?: any): AxiosPromise<Training> {
            return localVarFp.trainingsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsRead(id: number, options?: any): AxiosPromise<Training> {
            return localVarFp.trainingsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this training.
         * @param {Training} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingsUpdate(id: number, data: Training, options?: any): AxiosPromise<Training> {
            return localVarFp.trainingsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainingsApi - object-oriented interface
 * @export
 * @class TrainingsApi
 * @extends {BaseAPI}
 */
export class TrainingsApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsApprove(id: number, data: object, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsApprove(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Training} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsCreate(data: Training, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsDecline(id: number, data: object, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsDecline(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsDelete(id: number, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {Training} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsPartialUpdate(id: number, data: Training, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsRead(id: number, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this training.
     * @param {Training} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingsApi
     */
    public trainingsUpdate(id: number, data: Training, options?: AxiosRequestConfig) {
        return TrainingsApiFp(this.configuration).trainingsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {AddBankToTransaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAddBank: async (id: number, data: AddBankToTransaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsAddBank', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsAddBank', 'data', data)
            const localVarPath = `/transactions/{id}/add_bank/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsApprove: async (id: number, data: ApprovalForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsApprove', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsApprove', 'data', data)
            const localVarPath = `/transactions/{id}/approve/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsCreate: async (data: Transaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsCreate', 'data', data)
            const localVarPath = `/transactions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsDecline: async (id: number, data: ApprovalForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsDecline', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsDecline', 'data', data)
            const localVarPath = `/transactions/{id}/decline/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsDelete', 'id', id)
            const localVarPath = `/transactions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsExpenseList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/expense_list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsIncomeList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/income_list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPartialUpdate: async (id: number, data: Transaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsPartialUpdate', 'data', data)
            const localVarPath = `/transactions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPay: async (id: number, data: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsPay', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsPay', 'data', data)
            const localVarPath = `/transactions/{id}/pay/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsProfitLossSummary: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/profit_loss_summary/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsRead: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsRead', 'id', id)
            const localVarPath = `/transactions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsUpdate: async (id: number, data: Transaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('transactionsUpdate', 'data', data)
            const localVarPath = `/transactions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {AddBankToTransaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAddBank(id: number, data: AddBankToTransaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddBankToTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAddBank(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsApprove(id: number, data: ApprovalForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsApprove(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsCreate(data: Transaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsDecline(id: number, data: ApprovalForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsDecline(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsExpenseList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsExpenseList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsExpenseList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsIncomeList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsExpenseList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsIncomeList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsPartialUpdate(id: number, data: Transaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsPay(id: number, data: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsPay(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsProfitLossSummary(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsExpenseList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsProfitLossSummary(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsRead(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsUpdate(id: number, data: Transaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {AddBankToTransaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAddBank(id: number, data: AddBankToTransaction, options?: any): AxiosPromise<AddBankToTransaction> {
            return localVarFp.transactionsAddBank(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsApprove(id: number, data: ApprovalForm, options?: any): AxiosPromise<ApprovalForm> {
            return localVarFp.transactionsApprove(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsCreate(data: Transaction, options?: any): AxiosPromise<Transaction> {
            return localVarFp.transactionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {ApprovalForm} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsDecline(id: number, data: ApprovalForm, options?: any): AxiosPromise<ApprovalForm> {
            return localVarFp.transactionsDecline(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.transactionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsExpenseList(page?: number, pageSize?: number, options?: any): AxiosPromise<TransactionsExpenseList200Response> {
            return localVarFp.transactionsExpenseList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsIncomeList(page?: number, pageSize?: number, options?: any): AxiosPromise<TransactionsExpenseList200Response> {
            return localVarFp.transactionsIncomeList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsList(page?: number, pageSize?: number, options?: any): AxiosPromise<TransactionsList200Response> {
            return localVarFp.transactionsList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPartialUpdate(id: number, data: Transaction, options?: any): AxiosPromise<Transaction> {
            return localVarFp.transactionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPay(id: number, data: object, options?: any): AxiosPromise<object> {
            return localVarFp.transactionsPay(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsProfitLossSummary(page?: number, pageSize?: number, options?: any): AxiosPromise<TransactionsExpenseList200Response> {
            return localVarFp.transactionsProfitLossSummary(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsRead(id: number, options?: any): AxiosPromise<Transaction> {
            return localVarFp.transactionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this transaction.
         * @param {Transaction} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsUpdate(id: number, data: Transaction, options?: any): AxiosPromise<Transaction> {
            return localVarFp.transactionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {AddBankToTransaction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsAddBank(id: number, data: AddBankToTransaction, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsAddBank(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {ApprovalForm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsApprove(id: number, data: ApprovalForm, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsApprove(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Transaction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsCreate(data: Transaction, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {ApprovalForm} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsDecline(id: number, data: ApprovalForm, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsDecline(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsDelete(id: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsExpenseList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsExpenseList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsIncomeList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsIncomeList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {Transaction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsPartialUpdate(id: number, data: Transaction, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsPay(id: number, data: object, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsPay(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsProfitLossSummary(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsProfitLossSummary(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsRead(id: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this transaction.
     * @param {Transaction} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionsUpdate(id: number, data: Transaction, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


